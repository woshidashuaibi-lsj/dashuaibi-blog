---
title: "由前端网络安全到http，https和浏览器的存储（个人笔记）"
date: "2020-06-17"
tags: ["笔记"]
description: "常见的web攻击方式"
readtime: "18分钟"
words: "5366 字"
---

<!--more-->

常见的 web 攻击方式

-XSS

- CSRF
- 点击劫持
- SQL 注入
- OS 注入
- 请求劫持
- DDOS
  XSS
  参考：https://juejin.im/post/6844903685122703367#heading-18

Cross-Site scripting 跨站脚本攻击，因为和 css 同名所以改成 xss。

就比如一个掘金写文章的页面，假设掘金没有做 xss 攻击的脚本，我在我的文章里面写了<script>alert("攻击")<script>，那么当用户点开我的文章的时候就会有个 alert 提醒。过分一点，就用一个 while 循环无线重复 alert。也有可能写上一些 js 代码获取用户的 cookie,来帮助黑客恶意操作网站。

这是存储型的 xss 攻击。主要运用再存储到数据库这种的网站进行攻击。

还有一个反射型的 xss 攻击，

<input type="text" value="<%= getParameter("keyword") %>">
<button>搜索</button>

<div>
  您搜索的关键词是：<%= getParameter("keyword") %>
</div作者：美团技术团队链接：https://juejin.im/post/6844903685122703367来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
比如我们在一个input框输入一段恶意代码<script>alert("攻击")<script>，会形成如下的代码。

<input type="text" value=""><script>alert('XSS');</script>">
<button>搜索</button>

<div>
  您搜索的关键词是："><script>alert('XSS');</script>
</div>作者：美团技术团队链接：https://juejin.im/post/6844903685122703367来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
当浏览器请求 http://xxx/search?keyword="><script>alert('XSS');</script> 时是无法分辨的。

反射性的 xss 攻击是在 url 上操作的，如网站搜索、跳转等

DOM 型 XSS 的攻击步骤：

攻击者构造出特殊的 URL，其中包含恶意代码。
用户打开带有恶意代码的 URL。
用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

课外知识热点：

曾经在猫扑大杂烩中存在这样一个 XSS 漏洞，在用户发表回复的时候，程序对用户发表的内容做了严格的过滤，但是我不知道为什么，当用户编辑回复内容再次发表的时候，他却采用了另外一种不同的过滤方式，而这种过滤方式显然是不严密的，因此导致了 XSS 漏洞的出现。试想一下，像猫扑这样的大型社区，如果在一篇热帖中，利用 XSS 漏洞来使所有的浏览这篇帖子的用户都在不知不觉之中访问到了另外一个站点，如果这个站点同样是大型站点还好，但如果是中小型站点那就悲剧了，这将会引来多大的流量啊！更可怕的是，这些流量全部都是真实有效的！

解决方案：
对一些特殊的符号进行转义什么的，比如< > 什么的，

最好的办法就是配置白名单和黑名单。

CSRF
参考：https://www.bilibili.com/video/BV1iW411171s?from=search&seid=6829106872112135941

(Cross Site Request Forgery) 跨站请求伪造。
攻击者盗用你的身份，以你的名义去发送一些恶意请求。

比如你登陆进一个页面，然后进入转账页面

此时页面时保留了你的登录信息的，你没有关闭此页面，而是进入到一个黑客网站。如下网站的源代码，他的图片的路劲就是你转账的路劲。所以此时你的账户会被转账。

解决办法将 get 请求改成 post 请求这样就不能看到你的路径了

但是黑客同样有办法：通过表单 from 来提交接口

1. 解决方法加入一个验证码，因为他只是构造了一个请求，不能操作我们的也页面。

2. 验证 Refer 即同源策略，不是同域名同端口同协议的拒绝请求。

3. 在 form 表单或头信息中传递 token,token 存储在服务端，服务端通过拦截器验证有效性，检验失败的拒绝请求。

点击劫持
点击劫持是一种视觉欺骗的攻击手段,攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页， 应将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。就比如电影天堂的网站，当我随便点击一个电影。

结果就进入了一个其他页面（还挺想玩一玩的 TvT）。

这就是典型的点击劫持。页面使用 iframe 元素，将 iframe 透明化。就是吧这个跳转透明化。

解决办法：

1.  X-FRAME-OPTIONS 是一个 HTTP 响应头，就是为了防御 iframe 嵌套的点击劫持攻击
    DENY 页面不允许通过 iframe 方式展示
    SAPMEORIGIN 页面可以相同域名下通过 iframe 方式展示
    ALLOW-FROM 页面可以在指定来源的 iframe 中展示
    SQL 注入
    sql 注入是黑客通过当你输入密码的时候判断你的密码是否和我数据课里面的密码是否相同，黑客通过 1'or'1'='1 你前面的密码可能不是相同的但是后面的 1=1 返回的时 true,所以系统会判断你的密码时正确的。

解决方法:

1. 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入的变量嵌套到 SQL 语句中

2. 对进入数据库的特殊字符(',",\,<,>,&)等进行转义
   OS 注入
   和 sql 注入差不多的原理，不过它是针对操作系统的，通过 shell 偷偷开启你的终端，操作你的电脑。

解决方法：同 sql 解决方法

请求劫持
DNS 劫持：DNS 服务器（DNS 解析各个步骤）被纂改，修改域名解析的结果，使得访问到的不是预期的 ip。

http 劫持: 运营商劫持。升级为 https

DDOS
distributed denial of service（分布式拒绝服务）
DDOS 不是一个攻击的名称而是指一群攻击的合称。举个例子一个餐厅一次只能容纳 300 人一起吃饭，但是黑客一次叫 3000 个人去餐厅吃饭，餐厅根本容不下这么多人，于是就瘫痪了。DDOS 就是这样的原理操作了，我同时叫 100 个 ip 地址同时发送请求，你的网站承受不了如此大的点击量。

解决方案

1.备用一个网站（全静态的网站）。如果瘫痪了先暂时上这个网站。

2。http 请求拦截，如果同一个 ip 一直恶意请求，就直接把这个 ip 给封了。

3.有也那种 IP 你根本找不到的，那就可以带宽扩容，简单点就是你的饭店原来只能 300 人，现在我装修 3000 人也能坐的下，但是成本大，就给服务器怎加容量，这种看不到 ip 的攻击，黑客的成本也大。

以上就是前端常见的面试常问的网络安全放面的考点。上面也简单的说到过 get 和 post,http 和 https。下面我就顺带着一起讲一下，因为他们也是常考点。

get 和 post 的区别
先从原理上来了解 get 和 post,先将两个知识点，幂等和副作用。

副作用: 服务器上的资源是否改变。比如搜索服务器上的资源资源没有改动，是无副作用的。注册账号，资源改动是，副作用的。

幂等：指的是发送 M 和 N 次请求(M N 不相等且都大于 1)，服务器上的资源状态是否改变。比如对文章修改 10 次和 11 次是幂等的。而注册 10 次和注册 11 次是一样的，是不幂等的。

get 一般用于无副作用幂等的。即资源和它的状态都不改动。

post 一般用于副作用不幂等的。即资源和它的状态都改动了。

先前上面也提到过，get 请求的参数会被携带在 url 里面，很容易被人利用，而 post 不会，所以 post 比 get 更加安全一点。
post 支持更多的编码类型，且不被数据类型所限制。
get 请求能缓存，post 不能
http 和 https
http 是基于 TCP/IP 来传送超文本数据的。

https 是基于 http 的基础上加了一个 TLS 协议。

TLS 是使用了两种加密方式：

对称加密和非对称加密

对称加密：是指双方都有相同的密钥，双方用同一套加密规则加密，然后解密。

非对称加密：是我向大众宣布我的数据加密方法，然后解密方法只在我这里。

一般 TLS 加密是两种方法合并使用，我先用非对称加密，向大众发布我的加密方式，然后别人用这种加密方式，加密它的密钥给我，然后我就有了它的密钥，然后我们有了相同的密钥，这时候就用对称加密。

---

更新：看了一些大佬的文章，感觉自己 http 和 https 还是没有悟到，在整理整理这里。

TLS 是传输层加密协议，前身是 SSL 协议，由网景公司 1995 年发布，有时候两者不区分

http 协议以明文的方式发送传输数据，不提供任何加密方式，所以就很有可能被人窃取数据，并且读懂数据内容，所以 http 不能用来传输一些很重要的信息，比如密码什么的。

https 协议则是以 http 为基础来传输数据，不过在这上面加了一层 SSL 协议，用来加密传输的数据。

https 协议使用的是 443 端口，http 是 80 端口。

https 工作原理：

https 协议是需要申请证书的，这个证书就是一对私钥和密钥。客户端会检查对方的证书是否安全，不安全就会弹出证书安全的警告，如果安全就会用它的公钥对你私钥也就是一段随机值进行加密，发送给服务端，服务端和客户端就可以进行上面提到的对称加密了。

---

HTTP1.0，HTTP1.1，HTTP2.0
http1.0
特性：无状态，无连接的

无状态是指每次都无法保留用户的登陆记录和状态等等，只能通过 cookie session 来保存（服务器不跟踪不记录请求过的状态）

无连接是指每次发送请求都需要 tcp 三次握手，效率很低，并且在前一个请求响应到达之前才能发送下一个请求，如果前面的阻塞的话后面的都会被阻塞。

http1.1
为了解决 http1.0 的问题，http1.1 新增了一些新特性：长连接，管道化，缓存处理，断点传输。

长连接：数据传输完毕不关闭 tcp 连接，继续用这个通道传输数据。

管道化：没有管道化和长连接时，我们时 请求一=》响应一 请求二 =》响应二 请求三 =》 响应三。有管道化和长连接以后，我们 请求一 =》请求二=》请求三 =》响应一=》 响应二=》 响应三 管道化就不需要等到上一个请求响应之后才发第二个请求，但是即使你的请求二比请求一先完成但是响应依旧要按照顺序响应。

缓存处理：第一次请求到的一些数据放到缓存中，这样下次请求的时候就可以从本地缓存中拿。

http2.0
二进制分帧
多路复用： 在共享 TCP 链接的基础上同时发送请求和响应
头部压缩
服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求
二进制分帧:

将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码

多路复用:

基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，http 消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来

区别：

http1.0 到 http1.1 的主要区别，就是从无连接到长连接
http2.0 对比 1.X 版本主要区别就是多路复用
最后：
有时间再把 cookie,token 哪几种存储方式一起加到这里吧。
